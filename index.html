<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ììœ ì—°ìƒ ë¶„ì„ Tool</title>
  <style>
    :root{ --bg:#f7f9fc;--panel:#ffffff;--muted:#6b7280;--text:#111827;--border:#e5e7eb; --primary:#2563eb;--primary-700:#1d4ed8;--ok:#16a34a;--warn:#f59e0b }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:28px 20px;text-align:center}
    header h1{margin:0;font-size:24px}
    header p{margin:8px 0 0;color:var(--muted)}
    .wrap{max-width:1100px;margin:0 auto;padding:0 20px 60px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:18px;box-shadow:0 8px 24px rgba(17,24,39,.06);margin:14px 0}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    label{display:block;margin-bottom:6px;color:var(--muted);font-weight:600}
    input[type="text"],input[type="number"],select,textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#fff;color:var(--text)}
    textarea{min-height:84px;resize:vertical}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:10px;border:1px solid var(--primary);background:var(--primary);color:#fff;font-weight:700;cursor:pointer;transition:.2s}
    .btn:hover{transform:translateY(-1px);background:var(--primary-700)}
    .btn.secondary{background:#fff;color:var(--primary);border-color:var(--primary)}
    .btn.success{background:var(--ok);border-color:var(--ok)}
    .small{font-size:12px;color:var(--muted)}
    table{width:100%;border-collapse:separate;border-spacing:0 8px}
    th,td{text-align:left;padding:10px 12px;background:#fff;border:1px solid var(--border)}
    th{position:sticky;top:0;background:#f8fafc;z-index:1}
    tr td:first-child,tr th:first-child{border-top-left-radius:10px;border-bottom-left-radius:10px}
    tr td:last-child,tr th:last-child{border-top-right-radius:10px;border-bottom-right-radius:10px}
    .divider{height:1px;background:var(--border);margin:16px 0}
    .right{display:flex;justify-content:flex-end;gap:10px}
    .meta{display:flex;gap:10px;flex-wrap:wrap;margin:6px 0 10px}
    .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#eef2ff;border:1px solid #c7d2fe;color:#1e40af;font-size:12px}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#fff}
    .hide{display:none}
    .aware-values{max-height:160px;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:8px;background:#fff}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}

    /* ê²°ê³¼ í‘œ ì—´ ë„ˆë¹„ ì¡°ì • */
    table th:nth-child(1),
    table td:nth-child(1) { width: 230px; }  /* ëŒ€í‘œ ì‘ë‹µ */
    table th:nth-child(2),
    table td:nth-child(2) { width: 120px; }  /* ë¹ˆë„ */
    table th:nth-child(3),
    table td:nth-child(3) { width: 120px; }  /* ë¹„ìœ¨ */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <header>
    <h1>ğŸ” ììœ ì—°ìƒ ë¶„ì„ Tool</h1>
    <p>ë¸Œëœë“œ ë³´ì¡°ì¸ì§€ìë¥¼ Baseë¡œ ììœ ì—°ìƒ ì‘ë‹µì„ ë‹¨ì–´ ìœ ì‚¬ë„ ê¸°ë°˜ 1ì°¨ ë¶„ë¥˜í•©ë‹ˆë‹¤. í•„ìš”ì‹œ GPTë¥¼ í†µí•´ 2ì°¨ ë¶„ë¥˜í•©ë‹ˆë‹¤.</p>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="row">
        <div>
          <label>ë°ì´í„° íŒŒì¼ ì—…ë¡œë“œ (XLSX)</label>
          <input type="file" id="file" accept=".xlsx,.csv,.tsv,.txt" />
          <div class="small">ë¸Œë¼ìš°ì € ë‚´ì—ì„œë§Œ ì²˜ë¦¬ë©ë‹ˆë‹¤. XLSXëŠ” ì²« ë²ˆì§¸ ì‹œíŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.</div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <div>
          <label>ë³´ì¡°ì¸ì§€ ì—´</label>
          <select id="awareCol"></select>
        </div>
        <div>
          <label>ììœ ì—°ìƒ ì—´</label>
          <select id="faCol"></select>
        </div>
      </div>

      <div id="awarePickerCard" class="card hide" style="margin-top:14px">
        <div>
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <label style="margin-bottom:6px;">ì¸ì§€ì ê°’ ì„ íƒ</label>
            <div style="display:flex; gap:12px; align-items:center; font-size:13px; color:#555;">
              <label><input type="checkbox" id="chkAwareAllOn" style="margin-right:4px;">ì „ì²´ ì„ íƒ</label>
              <label><input type="checkbox" id="chkAwareAllOff" style="margin-right:4px;">ì „ì²´ í•´ì œ</label>
            </div>
          </div>
          <div id="awareValues" class="aware-values"></div>
          <div class="small" id="awareHint"></div>
          <div class="chips" id="awareSummary" style="margin-top:8px;"></div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <div>
          <label>ëª¨ë¦„/ì—†ìŒ íŒ¨í„´ (ì‰¼í‘œë¡œ êµ¬ë¶„)</label>
          <textarea id="unknowns">ëª¨ë¥´,ëª°ë¼,ëª°ë¦„,ëª¨ë¦„,ëª¨ë¦…,ëª¨ë¥¸,ëª¨ë¥´ê² ,ëª¨ë£¸,ëª°ê² ìŒ,ì—†,ì—†ìŒ,ì•–ìŒ,ì—†ìŠµ,ê¸€ì„,ì• ë§¤,ê·¸ëƒ¥,ë­ì§€,ì²˜ìŒ ë“¤ì–´,ì–´ë ¤ì›€,ì–´ë µ,ì´ê²Œ ë­,ì´ê²Œë­”ê°€,ìƒê° ì•ˆ,ìƒê°ì•Š,ìƒê°ì´ ì•ˆ,ìƒê°ì•ˆë‚¨,ê¸°ì–µ ì•ˆ,ê¸°ì–µì•Š,ê¸°ì–µì´ ì•ˆ,ê¸°ì–µì•ˆë‚¨, ì•ˆë– ì˜¤ë¦„</textarea>
        </div>
        <div>
          <div class="row" style="margin-top:0">
            <div>
              <label>ìœ ì‚¬ë„ ì„ê³„ê°’ (0.7â€“0.9 ê¶Œì¥)</label>
              <input type="number" id="threshold" value="0.8" min="0.5" max="0.99" step="0.01" />
            </div>
            <div>
              <label>ëª¨ë¦„/ì—†ìŒ ìœ ì‚¬ë„ ì„ê³„ê°’</label>
              <input type="number" id="unknownTh" value="0.8" min="0.5" max="0.99" step="0.01" />
            </div>
          </div>
          <div class="right" style="margin-top:12px">
            <button class="btn" id="btnAnalyze">ğŸš€ 1ì°¨ ë¶„ë¥˜ ì‹¤í–‰</button>
            <button class="btn success" id="btnDownloadXLSX" disabled>ğŸ“¥ ì—‘ì…€ë¡œ ë‚´ë ¤ë°›ê¸° (XLSX)</button>
          </div>
        </div>
      </div>
    </div>

    <!-- 2ì°¨ ë¶„ì„ (GPT ë¶„ë¥˜) ì„¹ì…˜: 1ì°¨ ì™„ë£Œ í›„ í™œì„±í™” -->
    <div id="gptSection" class="card hide" aria-disabled="true" style="opacity:.6; pointer-events:none;">
      <h3 style="margin:0 0 10px">2ì°¨ ë¶„ë¥˜ (ChatGPTë¡œ ë¶„ë¥˜í•˜ê¸°)</h3>
      <label for="gptInstruction">ë¶„ë¥˜ ì§€ì‹œë¬¸ (ì„ íƒ ì…ë ¥)</label>
      <textarea id="gptInstruction"></textarea>
      <div class="right" style="margin-top:12px">
        <button class="btn secondary" id="btnRunGPT" disabled>ğŸ§  2ì°¨ ë¶„ë¥˜ ì‹¤í–‰</button>
      </div>
    </div>

    <div id="results"></div>
  </div>

  <script>
  // ====== OpenAI í”„ë¡ì‹œ/ëª¨ë¸ ======
  const AI_PROXY_PATH = "https://branding1-team-server.vercel.app/api/ai-index";
  const TEAM_TOKEN     = "Branding1team_2025";
  const OPENAI_MODEL   = "gpt-4o";
  const MODEL_FOR_PROXY = "gpt-4o";  // íŒ€ ì„œë²„ í”„ë¡ì‹œìš© ëª¨ë¸ (gpt-4o-mini â†’ gpt-4o)

  // ì‚¬ìš©ìê°€ ì§€ì‹œë¬¸ì„ ë¹„ì›Œë„ ìë™ìœ¼ë¡œ ì ìš©í•  ê¸°ë³¸ ê°€ì´ë“œ
  const DEFAULT_GPT_GUIDE = `
  ì•„ë˜ ë°ì´í„°ëŠ” "1ì°¨ ë¶„ë¥˜ ê²°ê³¼ì˜ ëŒ€í‘œ ì‘ë‹µ ëª©ë¡"ì´ë©°, ê° í•­ëª©ì€ {text: ëŒ€í‘œ ì‘ë‹µ, count: ì‘ë‹µ ë¹ˆë„} í˜•ì‹ì´ì•¼.
  ê° ê·¸ë£¹ì—” ê°„ê²°í•œ í•œêµ­ì–´ ë¼ë²¨ì„ ë¶™ì—¬.
  ë°˜ë“œì‹œ JSON ê°ì²´ í•˜ë‚˜ë§Œ ì¶œë ¥í•˜ê³ , í˜•ì‹ì€ ë‹¤ìŒì„ ë”°ë¼:

  {
    "groups": [
      {
        "label": "ê·¸ë£¹ ì´ë¦„",
        "members": [
          { "text": "ëŒ€í‘œ ì‘ë‹µ", "count": 0 }
        ]
      }
    ]
  }

  ê·œì¹™:
  - **ì¤‘ìš”: ì•„ë˜ items ëª©ë¡ì˜ ëª¨ë“  í•­ëª©ì„ ë°˜ë“œì‹œ membersì— í¬í•¨í•´ì•¼ í•´. ë‹¨ í•˜ë‚˜ë„ ë¹ ëœ¨ë¦¬ì§€ ë§ˆ.**
  - **ì¤‘ìš”: ê°™ì€ í•­ëª©ì„ ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•˜ì§€ ë§ˆ. ê° í•­ëª©ì€ ì •í™•íˆ í•œ ë²ˆë§Œ í¬í•¨í•´.**
  - "members"ì—ëŠ” ì…ë ¥ itemsì˜ {text, count}ë¥¼ ê·¸ëŒ€ë¡œ ì“°ë˜, ì˜ë¯¸ê°€ ë¹„ìŠ·í•œ ëŒ€í‘œ ì‘ë‹µë“¤ë¼ë¦¬ë§Œ ë¬¶ì–´.
  - ë¼ë²¨ì€ ì§§ê³  ëª…í™•í•˜ê²Œ(ì˜ˆ: "ë§›/ìŒë£Œ", "ì„œë¹„ìŠ¤", "ë§¤ì¥/ë¶„ìœ„ê¸°").
  - ë¶„ë¥˜ê°€ ì• ë§¤í•œ í•­ëª©ë„ ê°€ì¥ ê°€ê¹Œìš´ ê·¸ë£¹ì— í¬í•¨ì‹œì¼œ.
  - ì„¤ëª… ë¬¸ì¥ì´ë‚˜ ì½”ë“œë¸”ë¡ ì—†ì´, JSONë§Œ ì¶œë ¥.
  `.trim();
  
  // ì‚¬ìš©ìê°€ ìˆ˜ì • ê°€ëŠ¥í•œ ê¸°ë³¸ ë¶„ë¥˜ ì§€ì‹œë¬¸
  const DEFAULT_USER_INSTRUCTION = "ë„ˆëŠ” í•œêµ­ì–´ ë°ì´í„° ë¶„ì„ê°€ì•¼. ì•„ë˜ ëŒ€í‘œ ì‘ë‹µì„ ê¸°ì¤€ìœ¼ë¡œ ìœ ì‚¬í•œ ì˜ë¯¸/ë§¥ë½/ë²”ì£¼ë¥¼ ì§€ë‹Œ ì‘ë‹µë“¤ì„ 3~12ê°œ ê·¸ë£¹ìœ¼ë¡œ ë¶„ë¥˜í•´ì¤˜.";
  
  // ---------- íŒŒì¼ ë¡œë“œ ----------
  async function readAsArrayBuffer(file){
    return await new Promise((res, rej)=>{const r=new FileReader(); r.onerror=()=>rej(r.error); r.onload=()=>res(r.result); r.readAsArrayBuffer(file)})
  }
  async function parseInput(file){
    const name=file.name.toLowerCase()
    const buf=await readAsArrayBuffer(file)
    if(name.endsWith('.xlsx')){
      const wb=XLSX.read(buf, {type:'array'})
      const ws=wb.Sheets[wb.SheetNames[0]]
      const rows=XLSX.utils.sheet_to_json(ws, {header:1, raw:true, defval:''})
      const header=(rows[0]||[]).map(String)
      const data=rows.slice(1)
      return {header,data}
    } else {
      const txt=new TextDecoder('utf-8').decode(buf)
      return parseAnyDelimited(txt)
    }
  }

  // ---------- ë‹¤ì¤‘ êµ¬ë¶„ì íŒŒì„œ (", ; | \t") ----------
  function parseAnyDelimited(text){
    const seps=new Set([',',';','|','\t'])
    const rows=[]; let i=0, field='', row=[], inQ=false
    const pushField=()=>{row.push(field); field=''}; const pushRow=()=>{rows.push(row); row=[]}
    while(i<text.length){
      const c=text[i]; const n=text[i+1]
      if(inQ){
        if(c==='"' && n==='"'){field+='"'; i+=2; continue}
        if(c==='"'){inQ=false; i++; continue}
        field+=c; i++; continue
      } else {
        if(c==='"'){inQ=true; i++; continue}
        if(c==='\r'){i++; continue}
        if(c==='\n'){pushField(); pushRow(); i++; continue}
        if(seps.has(c)){pushField(); i++; continue}
        field+=c; i++; continue
      }
    }
    pushField(); if(row.length) pushRow()
    const header=(rows[0]||[]).map(String)
    const data=rows.slice(1)
    return {header, data}
  }

  // ---------- ìœ ì‚¬ë„ (í•œê¸€ ìëª¨ ê³ ë ¤) ----------
  function containsHangul(s){return /[ê°€-í£]/.test(s)}
  function decomposeHangul(s){
    const CHO=["á„€","á„","á„‚","á„ƒ","á„„","á„…","á„†","á„‡","á„ˆ","á„‰","á„Š","á„‹","á„Œ","á„","á„","á„","á„","á„‘","á„’"]
    const JUNG=["á…¡","á…¢","á…£","á…¤","á…¥","á…¦","á…§","á…¨","á…©","á…ª","á…«","á…¬","á…­","á…®","á…¯","á…°","á…±","á…²","á…³","á…´","á…µ"]
    const JONG=["","á†¨","á†©","á†ª","á†«","á†¬","á†­","á†®","á†¯","á†°","á†±","á†²","á†³","á†´","á†µ","á†¶","á†·","á†¸","á†¹","á†º","á†»","á†¼","á†½","á†¾","á†¿","á‡€","á‡","á‡‚"]
    const out=[]; for(const ch of s){const code=ch.charCodeAt(0); if(code>=0xAC00 && code<=0xD7A3){const i=code-0xAC00; const c=Math.floor(i/588); const v=Math.floor((i%588)/28); const t=i%28; out.push(CHO[c],JUNG[v],JONG[t])} else out.push(ch)}
    return out
  }
  function lcs(a,b){const n=a.length,m=b.length; const dp=new Array(n+1).fill(0).map(()=>new Array(m+1).fill(0)); for(let i=1;i<=n;i++) for(let j=1;j<=m;j++) dp[i][j]= a[i-1]===b[j-1]? dp[i-1][j-1]+1 : Math.max(dp[i-1][j],dp[i][j-1]); return dp[n][m]}
  function baseSim(a,b){a=(a||'').trim().toLowerCase(); b=(b||'').trim().toLowerCase(); if(!a && !b) return 1; const l=lcs(a,b); return l/Math.max(a.length,b.length,1)}
  function jamoSim(a,b){const x=decomposeHangul((a||'').toLowerCase()), y=decomposeHangul((b||'').toLowerCase()); const n=Math.max(x.length,y.length)||1; let m=0; for(let i=0;i<n;i++) if(x[i]===y[i]) m++; return m/n}
  function calcSim(a,b){a=(a??'').toString(); b=(b??'').toString(); if(Math.abs(a.length-b.length)>=2) return 0; const base=baseSim(a,b); if(containsHangul(a+b)){return Math.max(base,jamoSim(a,b))} return base}

  function normalizeText(t){
    const str = (typeof t==='string' ? t : String(t || ''));
    return str
      .replace(/[\r\n\t]/g, '')  // ìºë¦¬ì§€ ë¦¬í„´, ì¤„ë°”ê¿ˆ, íƒ­ ì œê±°
      .replace(/\s+/g, ' ')       // ì—°ì† ê³µë°±ì„ í•˜ë‚˜ë¡œ
      .trim()                     // ì–‘ìª½ ê³µë°± ì œê±°
      .toLowerCase();             // ì†Œë¬¸ì ë³€í™˜
  }
  function isUnknownResponse(t, patterns, th){ if(!t||typeof t!=='string') return true; const x=normalizeText(t); if(!x) return true; if(patterns.some(p=>x.includes(p))) return true; return patterns.some(p=>calcSim(x,p)>=th) }
  function clusterResponses(series, th){const n=series.length; const used=new Set(); const clusters=[]; for(let i=0;i<n;i++){if(used.has(i)) continue; const base=series[i]; const cur=[i]; for(let j=i+1;j<n;j++){if(used.has(j)) continue; const s=calcSim(base, series[j]); if(s>=th){cur.push(j); used.add(j)}} clusters.push(cur); used.add(i)} return clusters}
  function valueCounts(arr){const m=new Map(); arr.forEach(v=>m.set(v,(m.get(v)||0)+1)); return [...m.entries()].sort((a,b)=>b[1]-a[1])}
  function prepareResults(dataCol, total, clusters){const out=[]; total=Math.max(1,total); for(const cl of clusters){const texts=cl.map(idx=>dataCol[idx]); const vc=valueCounts(texts); const representative=vc[0][0]; const originals=[...new Set(texts)].sort(); const count=texts.length; const ratio=Math.min(100, Math.max(0, count/total*100)); out.push({ëŒ€í‘œ_ì‘ë‹µ:representative, ì‘ë‹µ_ë¹ˆë„:count, ì‘ë‹µ_ë¹„ìœ¨:ratio / 100, í´ëŸ¬ìŠ¤í„°_ë‚´_ìœ ì‚¬ì‘ë‹µ:originals.join(', ')})} out.sort((a,b)=>Number(b.ì‘ë‹µ_ë¹ˆë„)-Number(a.ì‘ë‹µ_ë¹ˆë„)); return out}

  // ---------- ì „ì—­ ìƒíƒœ & DOM ----------
  const $file=document.getElementById('file')
  const $aware=document.getElementById('awareCol')
  const $fa=document.getElementById('faCol')
  const $unknowns=document.getElementById('unknowns')
  const $threshold=document.getElementById('threshold')
  const $unknownTh=document.getElementById('unknownTh')
  const $results=document.getElementById('results')
  const $btnAnalyze=document.getElementById('btnAnalyze')
  const $btnXLSX=document.getElementById('btnDownloadXLSX')
  const $btnRunGPT=document.getElementById('btnRunGPT')
  const $gptSection=document.getElementById('gptSection')

  const $awarePickerCard=document.getElementById('awarePickerCard')
  const $awareValues=document.getElementById('awareValues')
  const $awareHint=document.getElementById('awareHint')
  const $awareSummary=document.getElementById('awareSummary')

  const $gptInstruction=document.getElementById('gptInstruction')

  let parsed=null
  let lastExportRows=null
  let lastBrandLabel='ê²°ê³¼'
  let lastAwareCount=0
  let lastNonBlankCount=0
  let lastValidList=[] // 1ì°¨ ìœ íš¨ì‘ë‹µ(ëª¨ë¦„/ì—†ìŒ ì œì™¸)
  let lastGptGroups=null
  let awareMode='nonblank' // 'nonblank' | 'pick'

  function populateSelectors(){
    if(!parsed) return
    const opts = parsed.header.map((h,i)=>`<option value="${i}">${escapeHtml(h)}</option>`).join('')
    $aware.innerHTML=opts; $fa.innerHTML=opts
  }

  $file.addEventListener('change', async ()=>{
    resetUI()
    if(!$file.files.length) return
    parsed = await parseInput($file.files[0])
    populateSelectors()
  })

  $aware.addEventListener('change', ()=>{ renderAwarePicker() })

  function resetUI(){
    $results.innerHTML='';
    $btnXLSX.disabled=true; $btnRunGPT.disabled=true;
    lastExportRows=null; lastAwareCount=0; lastNonBlankCount=0; lastValidList=[]; lastGptGroups=null; hideAwarePicker();
    // 2ì°¨ ì„¹ì…˜ ë¹„í™œì„±í™”
    $gptSection.classList.add('hide');
    $gptSection.setAttribute('aria-disabled','true');
    $gptSection.style.opacity='.6';
    $gptSection.style.pointerEvents='none';
  }

  function hideAwarePicker(){
    awareMode='nonblank'; $awarePickerCard.classList.add('hide'); $awareValues.innerHTML=''; $awareHint.textContent=''; $awareSummary.innerHTML=''
  }

  // ì „ì²´ ì„ íƒ/í•´ì œ ì²´í¬ë°•ìŠ¤ í•¸ë“¤ëŸ¬
  function bindAwareMasterChecks() {
    const $chkOn  = document.getElementById('chkAwareAllOn');
    const $chkOff = document.getElementById('chkAwareAllOff');
    if (!$chkOn || !$chkOff) return;

    // ì „ì²´ ì„ íƒ
    $chkOn.addEventListener('change', () => {
      if ($chkOn.checked) {
        document.querySelectorAll('.aware-check').forEach(b => b.checked = true);
        $chkOff.checked = false;              // ìƒí˜¸ ë°°íƒ€
        updateAwareSummary();
      }
    });

    // ì „ì²´ í•´ì œ
    $chkOff.addEventListener('change', () => {
      if ($chkOff.checked) {
        document.querySelectorAll('.aware-check').forEach(b => b.checked = false);
        $chkOn.checked = false;               // ìƒí˜¸ ë°°íƒ€
        updateAwareSummary();
      }
    });

    // ê°œë³„ ì²´í¬ ë³€ê²½ ì‹œ ë§ˆìŠ¤í„° ì²´í¬ ìƒíƒœ ë™ê¸°í™”(ì„ íƒ ì‚¬í•­ì´ì§€ë§Œ ê¶Œì¥)
    document.addEventListener('change', (e) => {
      if (!e.target || !e.target.classList) return;
      if (!e.target.classList.contains('aware-check')) return;

      const boxes = [...document.querySelectorAll('.aware-check')];
      const total = boxes.length;
      const onCnt = boxes.filter(b => b.checked).length;

      if (onCnt === total) {
        $chkOn.checked  = true;
        $chkOff.checked = false;
      } else if (onCnt === 0) {
        $chkOn.checked  = false;
        $chkOff.checked = true;
      } else {
        // ì¼ë¶€ë§Œ ì„ íƒëœ ê²½ìš°: ë‘˜ ë‹¤ í•´ì œ
        $chkOn.checked  = false;
        $chkOff.checked = false;
      }
    });
  }

  function renderAwarePicker(){
    if(!parsed) return hideAwarePicker()
    const aIdx = Number($aware.value)
    if(Number.isNaN(aIdx)) return hideAwarePicker()
    const awareCol = parsed.data.map(r=> String(r[aIdx]??''))
    const values = awareCol.map(v=> v.trim()).filter(v=>v!=='')
    const uniq = [...new Set(values)]
    if(uniq.length<=1){ // ë‹¨ì¼ ê°’: ë³´ì¡°ì¸ì§€(ì¤‘ë³µ) ì „ì²´ ì¸ì§€ì ì²˜ë¦¬
      hideAwarePicker(); awareMode='nonblank';
      return
    }
    // ë‹¤ê°’: ì‚¬ìš©ì ì„ íƒ í•„ìš”
    awareMode='pick'
    $awarePickerCard.classList.remove('hide')
    const counts = new Map(); values.forEach(v=>counts.set(v,(counts.get(v)||0)+1))
    const items = uniq.sort((a,b)=> (counts.get(b)||0)-(counts.get(a)||0))
    $awareValues.innerHTML = items.map(v=>{
      const id='av_'+hashStr(v)
      const c=counts.get(v)||0
      return `<label style="display:flex;align-items:center;gap:8px;margin:6px 0">
        <input type="checkbox" class="aware-check" id="${id}" data-val="${escapeHtml(v)}" checked>
        <span>${escapeHtml(v)}</span>
        <span class="small" style="margin-left:auto;color:#6b7280">${c.toLocaleString()}ëª…</span>
      </label>`
    }).join('')
    $awareHint.textContent = 'í•´ë‹¹ ì—´ì˜ ì–´ë–¤ ì‘ë‹µì„ ì¸ì§€ìë¡œ ê°„ì£¼í• ì§€ ì„ íƒí•˜ì„¸ìš”.'
    updateAwareSummary()

    document.getElementById('chkAwareAllOn').checked  = false
    document.getElementById('chkAwareAllOff').checked = false

    bindAwareMasterChecks()
  }

  function getSelectedAwareSet(){
    if(awareMode==='nonblank') return null // nullì´ë©´ ë³´ì¡°ì¸ì§€(ì¤‘ë³µ) ì „ì²´
    const boxes=[...document.querySelectorAll('.aware-check')]
    const sel = new Set(boxes.filter(b=>b.checked).map(b=> b.getAttribute('data-val').toLowerCase()))
    return sel
  }

  function updateAwareSummary(){
    const sel = getSelectedAwareSet()
    if(sel===null){$awareSummary.innerHTML='<span class="chip">ê¸°ì¤€: ë³´ì¡°ì¸ì§€(ì¤‘ë³µ) ì „ì²´</span>'; return}
    if(sel.size===0){$awareSummary.innerHTML='<span class="chip" style="border-color:#fca5a5;color:#b91c1c">ì„ íƒ 0ê°œ (ëª¨ë‘ ë¯¸ì¸ì§€)</span>'; return}
    $awareSummary.innerHTML = `<span class="chip">ì„ íƒ ${sel.size}ì¢…</span>`
  }

  document.addEventListener('change',(e)=>{ if(e.target && e.target.classList && e.target.classList.contains('aware-check')) updateAwareSummary() })

  // ---------- ë¶„ì„ ì‹¤í–‰ ----------
  $btnAnalyze.addEventListener('click', ()=>{
    if(!parsed){alert('ë¨¼ì € íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”.'); return}
    const aIdx = Number($aware.value), fIdx = Number($fa.value)
    if(Number.isNaN(aIdx)||Number.isNaN(fIdx)){alert('ë³´ì¡° ì¸ì§€ ì—´ê³¼ ììœ ì—°ìƒ ì—´ì„ ê°ê° í•˜ë‚˜ì”© ì„ íƒí•˜ì„¸ìš”.'); return}

    const patterns = $unknowns.value.split(',').map(s=>normalizeText(s)).filter(Boolean)
    const th = Number($threshold.value||0.8)
    const uth = Number($unknownTh.value||0.8)

    const awareCol = parsed.data.map(r=> String(r[aIdx]??''))
    const faCol = parsed.data.map(r=> String(r[fIdx]??''))

    let isAware=[]; let awareCriterionLabel='ë³´ì¡°ì¸ì§€(ì¤‘ë³µ)'
    if(awareMode==='pick'){
      const sel = getSelectedAwareSet()
      if(sel.size===0){ alert('ì¸ì§€ìë¡œ ê°„ì£¼í•  ê°’ì„ 1ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.'); return }
      isAware = awareCol.map(v=> sel.has(v.trim().toLowerCase()))
      awareCriterionLabel = 'ì„ íƒê°’('+[...sel].join(', ')+')'
    } else {
      isAware = awareCol.map(v=> v.trim()!=='')
      awareCriterionLabel = 'ë³´ì¡°ì¸ì§€(ì¤‘ë³µ)'
    }

    const filtered = faCol.filter((_,i)=> isAware[i])
    lastAwareCount = isAware.filter(x=>x).length
    lastNonBlankCount = filtered.filter(v=> v.trim()!=='').length

    const flags = filtered.map(v=> isUnknownResponse(v, patterns, uth))
    const unknown = filtered.filter((_,i)=>flags[i])
    const valid = filtered.filter((_,i)=>!flags[i])
    const total = filtered.length

    let rows=[]
    if(valid.length){
      const clusters = clusterResponses(valid, th)
      rows = prepareResults(valid, total, clusters)
      if(unknown.length){
        const ratio = Math.min(100, (unknown.length/total)*100)
        rows.push({ëŒ€í‘œ_ì‘ë‹µ:'ëª¨ë¦„/ì—†ìŒ', ì‘ë‹µ_ë¹ˆë„:unknown.length, ì‘ë‹µ_ë¹„ìœ¨:ratio / 100, í´ëŸ¬ìŠ¤í„°_ë‚´_ìœ ì‚¬ì‘ë‹µ:[...new Set(unknown)].join(', ')})
      }
    } else {
      rows=[{ëŒ€í‘œ_ì‘ë‹µ:'ëª¨ë¦„/ì—†ìŒ', ì‘ë‹µ_ë¹ˆë„:String(total), ì‘ë‹µ_ë¹„ìœ¨:'100.0%', í´ëŸ¬ìŠ¤í„°_ë‚´_ìœ ì‚¬ì‘ë‹µ:'ì „ì²´ ë¬´ì‘ë‹µ'}]
    }

    // ê²°ê³¼ ì˜ì—­: 1ì°¨ ìµœì‹  ë²„ì „ìœ¼ë¡œ ë®ì–´ì“°ê¸°
    $results.innerHTML=''
    const card=document.createElement('div'); card.className='card'
    lastBrandLabel = parsed.header[fIdx] || 'ê²°ê³¼'
    const title=document.createElement('h3'); title.textContent=`ğŸ“Œ 1ì°¨ ê²°ê³¼ â€” ${lastBrandLabel}`; title.style.margin='0 0 8px'
    card.appendChild(title)

    const meta=document.createElement('div'); meta.className='meta'
    meta.innerHTML = `<span class="pill">ì¸ì§€ ê¸°ì¤€: ${escapeHtml(awareCriterionLabel)}</span>`+
                     `<span class="pill">ì¸ì§€ì ìˆ˜: ${lastAwareCount.toLocaleString()}</span>`;
    card.appendChild(meta)

    const tbl = document.createElement('div'); tbl.style.overflow='auto'
    tbl.innerHTML = renderTable(
      [{key:'ëŒ€í‘œ_ì‘ë‹µ', label:'ëŒ€í‘œ ì‘ë‹µ'},{key:'ì‘ë‹µ_ë¹ˆë„', label:'ë¹ˆë„'},{key:'ì‘ë‹µ_ë¹„ìœ¨', label:'ë¹„ìœ¨'},{key:'í´ëŸ¬ìŠ¤í„°_ë‚´_ìœ ì‚¬ì‘ë‹µ', label:'ì‘ë‹µ í´ëŸ¬ìŠ¤í„°'}],
      rows
    )
    card.appendChild(tbl)
    $results.appendChild(card)

    lastExportRows = rows
    lastValidList = valid
    $btnXLSX.disabled = false

    // 2ì°¨ ì„¹ì…˜ í™œì„±í™” (1ì°¨ ì™„ë£Œì‹œ)
    const enable2nd = Array.isArray(lastExportRows)
      && lastExportRows.some(r => String(r['ëŒ€í‘œ_ì‘ë‹µ']).trim() && String(r['ëŒ€í‘œ_ì‘ë‹µ']).trim() !== 'ëª¨ë¦„/ì—†ìŒ');
    $btnRunGPT.disabled = !enable2nd
    $gptSection.classList.toggle('hide', !enable2nd)
    $gptSection.setAttribute('aria-disabled', enable2nd? 'false':'true')
    
    // 2ì°¨ ì„¹ì…˜ í™œì„±í™” ì‹œ ê¸°ë³¸ ì§€ì‹œë¬¸ ìë™ ì…ë ¥ (ë¹„ì–´ìˆì„ ë•Œë§Œ)
    if (enable2nd && !$gptInstruction.value.trim()) {
      $gptInstruction.value = DEFAULT_USER_INSTRUCTION;
    }
    $gptSection.style.opacity = enable2nd? '1' : '.6'
    $gptSection.style.pointerEvents = enable2nd? 'auto' : 'none'

    window.__awareCriterionLabel = awareCriterionLabel
  })

  // ---------- OpenAI 2ì°¨ ë¶„ë¥˜ ----------
  $btnRunGPT.addEventListener('click', async () => {
    console.log('ğŸ¯ 2ì°¨ ë¶„ë¥˜ ë²„íŠ¼ í´ë¦­ë¨!');
    console.log('lastValidList:', lastValidList);
    console.log('lastExportRows:', lastExportRows);
    
    if (!lastValidList.length) { 
      alert('ë¨¼ì € 1ì°¨ ë¶„ì„ì„ ì‹¤í–‰í•˜ì„¸ìš”.'); 
      console.error('âŒ lastValidListê°€ ë¹„ì–´ìˆìŒ');
      return;
    }

    // 1ì°¨ í‘œ(lastExportRows)ì—ì„œ ëŒ€í‘œ ì‘ë‹µ/ë¹ˆë„ë¥¼ ì‚¬ìš©
    if (!lastExportRows || !lastExportRows.length) {
      alert('ë¨¼ì € 1ì°¨ ë¶„ì„ì„ ì‹¤í–‰í•˜ì„¸ìš”.'); return;
    }
    console.log('ğŸ“Š lastExportRows ê°œìˆ˜:', lastExportRows?.length);
    
    let items = (lastExportRows || [])
      .filter(r => {
        const text = normalizeText(r['ëŒ€í‘œ_ì‘ë‹µ']);
        return text && text !== 'ëª¨ë¦„/ì—†ìŒ';
      })
      .map(r => ({
        text: normalizeText(r['ëŒ€í‘œ_ì‘ë‹µ']),
        count: Number(r['ì‘ë‹µ_ë¹ˆë„']) || 0
      }))
      .filter(it => it.text);
    
    console.log('ğŸ“Š í•„í„°ë§ í›„ items ê°œìˆ˜:', items.length);
    
    if (!items.length) { 
      alert('ëŒ€í‘œ ì‘ë‹µì´ ì—†ìŠµë‹ˆë‹¤.'); 
      console.error('âŒ itemsê°€ ë¹„ì–´ìˆìŒ');
      return; 
    }

    // í•­ëª©ì´ ë„ˆë¬´ ë§ìœ¼ë©´ ê²½ê³  ë° ìë™ ì œí•œ
    if (items.length > 300) {  // ì•ˆì •ì„±ì„ ìœ„í•´ 300ê°œë¡œ ì œí•œ
      const originalLength = items.length;
      
      // ë¹ˆë„ ìˆœìœ¼ë¡œ ì •ë ¬ í›„ ìƒìœ„ 300ê°œë§Œ ì„ íƒ
      items.sort((a, b) => b.count - a.count);
      const excludedItems = items.slice(300);
      items = items.slice(0, 300);
      
      console.log('âœ‚ï¸ ìƒìœ„ 300ê°œë¡œ ìë™ ì œí•œ:', items.length);
      console.log('ğŸ“Š ì œì™¸ëœ í•­ëª©:', excludedItems.length);
      console.log(`âš ï¸ ì•ˆë‚´: ${originalLength}ê°œ í•­ëª© ì¤‘ ë¹ˆë„ ìƒìœ„ 300ê°œë§Œ 2ì°¨ ë¶„ë¥˜ì— ì‚¬ìš©í•©ë‹ˆë‹¤.`);
    }

    // ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë¶„ë¥˜ ì§€ì‹œë¬¸ (UIì—ì„œ ìˆ˜ì • ê°€ëŠ¥)
    const userInstruction = ($gptInstruction.value || '').trim();
    
    // ì‚¬ìš©ì ì§€ì‹œë¬¸ì´ ì—†ìœ¼ë©´ ì—ëŸ¬
    if (!userInstruction) {
      alert('ë¶„ë¥˜ ì§€ì‹œë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    try {
      $btnRunGPT.disabled = true; 
      $btnRunGPT.textContent = 'ë¶„ë¥˜ ì¤‘â€¦';

      // í”„ë¡¬í”„íŠ¸ êµ¬ì„±: ì‚¬ìš©ì ì§€ì‹œë¬¸ + ê³ ì • ê°€ì´ë“œ + items
      const fullPrompt =
        userInstruction + "\n\n" +
        DEFAULT_GPT_GUIDE + "\n\n" +
        "ì•„ë˜ëŠ” items ëª©ë¡ì´ì•¼(JSON):\n" + JSON.stringify(items, null, 2);

      console.log('ğŸ“¤ ì „ì†¡í•  í”„ë¡¬í”„íŠ¸ ê¸¸ì´:', fullPrompt.length);
      console.log('ğŸ“¤ ì „ì†¡í•  í”„ë¡¬í”„íŠ¸ (ì²˜ìŒ 500ì):', fullPrompt.substring(0, 500));
      console.log('ğŸ“Š items ê°œìˆ˜:', items.length);

      // ğŸ¯ íŒ€ ì„œë²„ê°€ ê¸°ëŒ€í•˜ëŠ” í˜•ì‹ (íŒŒì‹± ì½”ë“œì™€ ë™ì¼)
      const payload = {
        model: MODEL_FOR_PROXY,
        prompt: {
          system: "ë„ˆëŠ” í•œêµ­ì–´ ë°ì´í„° ë¶„ì„ê°€ì´ë©°, JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•´ì•¼ í•´. ì ˆëŒ€ë¡œ ê°™ì€ í•­ëª©ì„ ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•˜ì§€ ë§ˆ. ê° í•­ëª©ì€ ì •í™•íˆ í•œ ë²ˆë§Œ í¬í•¨í•´.",
          user: fullPrompt
        },
        maxTokens: 16000  // GPT-4oëŠ” ìµœëŒ€ 16K ì¶œë ¥ ê°€ëŠ¥, 500ê°œ í•­ëª© ì²˜ë¦¬
      };
      
      console.log('ğŸ“¦ ì „ì†¡í•  payload:', JSON.stringify(payload, null, 2).substring(0, 1000));

      // ğŸ¯ íŒ€ ì„œë²„ í”„ë¡ì‹œì— ë§ëŠ” í˜•ì‹ìœ¼ë¡œ ë‹¨ì¼ í˜¸ì¶œ
      console.log('ğŸš€ ìš”ì²­ ì‹œì‘...');
      console.log('ğŸ“ Payload í¬ê¸°:', JSON.stringify(payload).length, 'ë°”ì´íŠ¸');
      
      let res;
      try {
        res = await fetch(AI_PROXY_PATH, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-team-token': TEAM_TOKEN
          },
          body: JSON.stringify(payload)
        });
      } catch (fetchError) {
        console.error('âŒ Fetch ì‹¤íŒ¨ ìƒì„¸:');
        console.error('  message:', fetchError.message);
        console.error('  name:', fetchError.name);
        console.error('  stack:', fetchError.stack);
        console.error('  ì „ì²´:', fetchError);
        throw new Error(`ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì‹¤íŒ¨: ${fetchError.message}. í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ê¸¸ê±°ë‚˜ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
      }

      console.log('âœ… ì‘ë‹µ ìˆ˜ì‹ :', res.status, res.statusText);

      if (!res.ok) {
        const errorText = await res.text();
        console.error('âŒ ì„œë²„ ì—ëŸ¬ ì‘ë‹µ:', errorText);
        throw new Error(`HTTP ${res.status}: ${res.statusText} - ${errorText.substring(0, 200)}`);
      }

      const data = await res.json();
      console.log('âœ… API ì‘ë‹µ ì „ì²´:', JSON.stringify(data, null, 2));

      // ì‘ë‹µì—ì„œ content ì¶”ì¶œ (íŒŒì‹± ì½”ë“œì™€ ë™ì¼í•œ ë°©ì‹)
      const responseText = data?.choices?.[0]?.message?.content || data?.text || data?.content || '';
      console.log('ğŸ“ ì‘ë‹µ í…ìŠ¤íŠ¸ (ì „ì²´):', responseText);
      console.log('ğŸ“ ì‘ë‹µ í…ìŠ¤íŠ¸ íƒ€ì…:', typeof responseText);

      // 1) data ê°ì²´ì—ì„œ ì§ì ‘ íŒŒì‹± ì‹œë„
      console.log('ğŸ”„ ì‹œë„ 1: data ê°ì²´ ì§ì ‘ íŒŒì‹±');
      let groups = normalizeGptGroups(data);
      console.log('ê²°ê³¼ 1:', groups);
      
      // 2) responseTextë¥¼ JSONìœ¼ë¡œ íŒŒì‹± ì‹œë„
      if (!groups || !groups.length) {
        console.log('ğŸ”„ ì‹œë„ 2: responseText JSON íŒŒì‹±');
        try {
          const parsed = JSON.parse(responseText);
          console.log('íŒŒì‹±ëœ JSON:', parsed);
          groups = normalizeGptGroups(parsed);
          console.log('ê²°ê³¼ 2:', groups);
        } catch (e) {
          console.warn('JSON íŒŒì‹± ì‹¤íŒ¨:', e.message);
        }
      }
      
      // 3) responseTextë¥¼ í…ìŠ¤íŠ¸ë¡œ íŒŒì‹± ì‹œë„
      if (!groups || !groups.length) {
        console.log('ğŸ”„ ì‹œë„ 3: responseText í…ìŠ¤íŠ¸ íŒŒì‹±');
        groups = parseGroupsFromText(responseText);
        console.log('ê²°ê³¼ 3:', groups);
      }
      
      // 4) dataê°€ ë¬¸ìì—´ì¸ ê²½ìš°
      if (!groups || !groups.length) {
        console.log('ğŸ”„ ì‹œë„ 4: data ë¬¸ìì—´ íŒŒì‹±');
        if (typeof data === 'string') {
          groups = parseGroupsFromText(data);
          console.log('ê²°ê³¼ 4:', groups);
        }
      }
      
      console.log('=== ìµœì¢… normalizeGptGroups ê²°ê³¼ ===');
      console.log(groups);

      if (!groups || !groups.length) {
        console.error('=== íŒŒì‹± ì‹¤íŒ¨ - ì›ë³¸ ë°ì´í„° ===');
        console.error(data);
        throw new Error('ìœ íš¨í•œ ê·¸ë£¹ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ê°œë°œì ë„êµ¬ ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
      }

      // ========================================
      // ğŸ¯ í•µì‹¬ ë¡œì§: 1ì°¨ ì›ë³¸ ë°ì´í„°ë¡œ ì™„ì „íˆ ì¬êµ¬ì„±
      // ========================================
      console.log('ğŸ”§ 2ì°¨ ë¶„ë¥˜ ê²°ê³¼ë¥¼ 1ì°¨ ì›ë³¸ ë°ì´í„°ë¡œ ì¬êµ¬ì„± ì‹œì‘...');
      
      // 1. 1ì°¨ ì›ë³¸ ë°ì´í„°ë¥¼ Mapìœ¼ë¡œ êµ¬ì„± (text â†’ {count, ratio})
      const originalDataMap = new Map();
      (lastExportRows || []).forEach(r => {
        const text = normalizeText(r['ëŒ€í‘œ_ì‘ë‹µ']);
        if (text) {
          const count = Number(r['ì‘ë‹µ_ë¹ˆë„']) || 0;
          const ratio = Number(r['ì‘ë‹µ_ë¹„ìœ¨']) || 0;
          
          // ì´ë¯¸ ì¡´ì¬í•˜ë©´ ë¹ˆë„ í•©ì‚°
          if (originalDataMap.has(text)) {
            const existing = originalDataMap.get(text);
            originalDataMap.set(text, {
              count: existing.count + count,
              ratio: existing.ratio + ratio
            });
            console.log(`  â„¹ï¸ ì¤‘ë³µ í…ìŠ¤íŠ¸ í•©ì‚°: "${text}" (ê¸°ì¡´: ${existing.count}, ì¶”ê°€: ${count}, í•©ê³„: ${existing.count + count})`);
          } else {
            originalDataMap.set(text, { count, ratio });
          }
        }
      });
      console.log(`âœ… 1ì°¨ ì›ë³¸ ë°ì´í„° ë§µ ìƒì„±: ${originalDataMap.size}ê°œ í•­ëª©`);
      
      // 2. GPTê°€ ë¶„ë¥˜í•œ í•­ëª©ë“¤ì„ ì¶”ì 
      const classifiedTexts = new Set();
      
      // 3. GPT ê²°ê³¼ì˜ ê° ê·¸ë£¹ì„ 1ì°¨ ì›ë³¸ìœ¼ë¡œ ì¬êµ¬ì„±
      const reconstructedGroups = [];
      
      groups.forEach(g => {
        const label = String(g.label || '').trim();
        if (!label) return;
        
        const members = [];
        (g.members || []).forEach(m => {
          const text = normalizeText(m.text);
          if (!text) return;
          
          // ì¤‘ë³µ ì²´í¬
          if (classifiedTexts.has(text)) {
            console.warn(`âš ï¸ ì¤‘ë³µ í•­ëª© ë¬´ì‹œ: "${text}" (ê·¸ë£¹ "${label}")`);
            return;
          }
          
          // 1ì°¨ ì›ë³¸ì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
          const originalData = originalDataMap.get(text);
          if (originalData) {
            members.push({
              text: text,
              count: originalData.count,
              ratio: originalData.ratio
            });
            classifiedTexts.add(text);
          } else {
            console.warn(`âš ï¸ 1ì°¨ ì›ë³¸ì— ì—†ëŠ” í•­ëª©: "${text}" (GPTê°€ ì„ì˜ ìƒì„±, ë¬´ì‹œí•¨)`);
          }
        });
        
        if (members.length > 0) {
          reconstructedGroups.push({ label, members });
        }
      });
      
      console.log(`âœ… GPT ë¶„ë¥˜ ì¬êµ¬ì„± ì™„ë£Œ: ${reconstructedGroups.length}ê°œ ê·¸ë£¹, ${classifiedTexts.size}ê°œ í•­ëª©`);
      
      // 4. GPTê°€ ëˆ„ë½í•œ í•­ëª©ë“¤ ì¶”ê°€
      const unclassifiedMembers = [];
      items.forEach(item => {
        const text = normalizeText(item.text);
        if (!classifiedTexts.has(text)) {
          const originalData = originalDataMap.get(text);
          if (originalData) {
            unclassifiedMembers.push({
              text: text,
              count: originalData.count,
              ratio: originalData.ratio
            });
            classifiedTexts.add(text);
          }
        }
      });
      
      if (unclassifiedMembers.length > 0) {
        console.log(`ğŸ“Š GPT ëˆ„ë½ í•­ëª©: ${unclassifiedMembers.length}ê°œ`);
        // 'ëˆ„ë½ëœ ë¶„ë¥˜'ë¥¼ ë³„ë„ ê·¸ë£¹ìœ¼ë¡œ ì¶”ê°€í•˜ì§€ ì•Šê³  ë‚˜ì¤‘ì— 'ê¸°íƒ€'ì— í•©ì¹¨
        // ì„ì‹œë¡œ ì €ì¥ë§Œ í•´ë‘ 
      }
      
      // 5. ìƒìœ„ ì œí•œìœ¼ë¡œ ì œì™¸ëœ í•­ëª©ë“¤ + ëˆ„ë½ í•­ëª©ì„ í•©ì³ì„œ 'ê¸°íƒ€' ê·¸ë£¹ ìƒì„±
      const etcMembers = [...unclassifiedMembers];  // ëˆ„ë½ í•­ëª© í¬í•¨
      
      if (items.length < originalDataMap.size - 1) {  // -1ì€ "ëª¨ë¦„/ì—†ìŒ" ì œì™¸
        const excludedMembers = [];
        const itemTexts = new Set(items.map(it => normalizeText(it.text)));
        
        originalDataMap.forEach((data, text) => {
          if (text !== 'ëª¨ë¦„/ì—†ìŒ' && !itemTexts.has(text) && !classifiedTexts.has(text)) {
            excludedMembers.push({
              text: text,
              count: data.count,
              ratio: data.ratio
            });
            classifiedTexts.add(text);
          }
        });
        
        if (excludedMembers.length > 0) {
          console.log(`ğŸ“Š ìƒìœ„ ì œí•œ ì œì™¸ í•­ëª©: ${excludedMembers.length}ê°œ`);
          // etcMembersì— í•©ì¹˜ê¸°
          etcMembers.push(...excludedMembers);
        }
      }
      
      // 'ê¸°íƒ€' ê·¸ë£¹ ì¶”ê°€ (ëˆ„ë½ + ì œì™¸ í•­ëª© í•©ì³ì„œ)
      if (etcMembers.length > 0) {
        console.log(`ğŸ“Š ê¸°íƒ€ ê·¸ë£¹ ìƒì„±: ${etcMembers.length}ê°œ í•­ëª© (ëˆ„ë½ + ì œì™¸)`);
        reconstructedGroups.push({
          label: 'ê·¸ ì™¸ ì‘ë‹µ',
          members: etcMembers
        });
      }
      
      // 6. "ëª¨ë¦„/ì—†ìŒ" í•­ëª© ì¶”ê°€
      const unknownData = originalDataMap.get('ëª¨ë¦„/ì—†ìŒ');
      if (unknownData) {
        reconstructedGroups.push({
          label: 'ëª¨ë¦„/ì—†ìŒ',
          members: [{
            text: 'ëª¨ë¦„/ì—†ìŒ',
            count: unknownData.count,
            ratio: unknownData.ratio
          }]
        });
        classifiedTexts.add('ëª¨ë¦„/ì—†ìŒ');
      }
      
      // 7. ìµœì¢… ê²€ì¦
      console.log('ğŸ” ìµœì¢… ê²€ì¦...');
      let total1st = 0;
      let total2nd = 0;
      
      originalDataMap.forEach(data => {
        total1st += data.count;
      });
      
      reconstructedGroups.forEach(g => {
        g.members.forEach(m => {
          total2nd += m.count;
        });
      });
      
      console.log(`ğŸ“Š 1ì°¨ ë¶„ë¥˜ ì „ì²´ ë¹ˆë„: ${total1st}`);
      console.log(`ğŸ“Š 2ì°¨ ë¶„ë¥˜ ì „ì²´ ë¹ˆë„: ${total2nd}`);
      console.log(`ğŸ“Š ì°¨ì´: ${total1st - total2nd}`);
      
      if (total1st === total2nd) {
        console.log('âœ…âœ…âœ… ë¹ˆë„ ì™„ë²½ ì¼ì¹˜!');
      } else {
        console.error(`âŒ ë¹ˆë„ ë¶ˆì¼ì¹˜! ì°¨ì´: ${total1st - total2nd}`);
        alert(`âš ï¸ ë¹ˆë„ ë¶ˆì¼ì¹˜ ê°ì§€: ${total1st - total2nd}\nì½˜ì†”(F12)ì„ í™•ì¸í•˜ì„¸ìš”.`);
      }

      lastGptGroups = reconstructedGroups;
      renderGptGroups(reconstructedGroups);
      
    } catch (err) {
      alert('2ì°¨ ë¶„ë¥˜ ì‹¤íŒ¨: ' + (err.message || err));
      console.error('ì „ì²´ ì˜¤ë¥˜:', err);
    } finally {
      $btnRunGPT.disabled = false; 
      $btnRunGPT.textContent = 'ğŸ§  2ì°¨ ë¶„ë¥˜ ì‹¤í–‰';
    }
  });

  // ëª¨ë¸ ì¶œë ¥ì—ì„œ JSONë§Œ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ/íŒŒì‹±
  function parseGroupsFromText(text) {
    if (!text) return null;
    let cleaned = String(text).trim()
      .replace(/^```json\s*/i, '')
      .replace(/^```\s*/i, '')
      .replace(/```$/i, '')
      .trim();

    // 1) ë°”ê¹¥ JSON ë°”ë¡œ íŒŒì‹± ì‹œë„
    try {
      const obj = JSON.parse(cleaned);
      return normalizeGptGroups(obj);
    } catch {}

    // 2) ë³¸ë¬¸ì—ì„œ ê°€ì¥ ë°”ê¹¥ { ... } ë¸”ë¡ì„ ì°¾ì•„ íŒŒì‹±
    const m = cleaned.match(/\{[\s\S]*\}/);
    if (m) {
      try {
        const obj = JSON.parse(m[0]);
        return normalizeGptGroups(obj);
      } catch {}
    }
    return null;
  }

  // ---------- ì—‘ì…€(XLSX) ë‚´ë³´ë‚´ê¸° ----------
  $btnXLSX.addEventListener('click', ()=>{
    if(!lastExportRows){alert('ë¨¼ì € ë¶„ì„ì„ ì‹¤í–‰í•˜ì„¸ìš”.'); return}

    const header = [
      { key:'ëŒ€í‘œ_ì‘ë‹µ',            label:'ëŒ€í‘œ ì‘ë‹µ' },
      { key:'ì‘ë‹µ_ë¹ˆë„',            label:'ë¹ˆë„' },
      { key:'ì‘ë‹µ_ë¹„ìœ¨',            label:'ë¹„ìœ¨' },
      { key:'í´ëŸ¬ìŠ¤í„°_ë‚´_ìœ ì‚¬ì‘ë‹µ',  label:'ì‘ë‹µ í´ëŸ¬ìŠ¤í„°' }
    ];
    const metaRows = [
      ['ë¸Œëœë“œ(ììœ ì—°ìƒ ì—´)', lastBrandLabel],
      ['ì¸ì§€ ê¸°ì¤€', String(window.__awareCriterionLabel||'ë³´ì¡°ì¸ì§€(ì¤‘ë³µ)')],
      ['ì¸ì§€ì ìˆ˜', String(lastAwareCount)],
      ['',''],
    ]
    const ws1 = XLSX.utils.aoa_to_sheet([
      ...metaRows,
      header.map(h => h.label),
      ...lastExportRows.map(r => header.map(h => r[h.key] ?? ''))
    ])
    ws1['!cols']=[{wch:20},{wch:12},{wch:12},{wch:60}]

    if(ws1['C6']) ws1['C6'].z = "0.0%";
    for(let R = 6; ws1[`C${R}`]; R++){ ws1[`C${R}`].z = "0.0%"; }

    const wb = XLSX.utils.book_new()
    const sheetName1 = safeSheetName(lastBrandLabel)
    XLSX.utils.book_append_sheet(wb, ws1, sheetName1)

    // ì‹œíŠ¸2: GPT 2ì°¨ ë¶„ë¥˜(ìˆë‹¤ë©´)
    if(lastGptGroups && Array.isArray(lastGptGroups)){
      const gHeader=['ê·¸ë£¹','ì‘ë‹µ','ë¹ˆë„','ë¹„ìœ¨']
      const gRows = []
      
      // ì „ì²´ ë¹ˆë„ ê³„ì‚°
      const grandTotal = lastGptGroups.reduce((sum, g) => 
        sum + g.members.reduce((s, m) => s + (m.count || 0), 0), 0
      );
      
      // ê° ê·¸ë£¹ì˜ ê° ì‘ë‹µì„ í–‰ìœ¼ë¡œ ì¶”ê°€
      lastGptGroups.forEach(g=>{
        // ê·¸ë£¹ëª…ì€ ì´ë¯¸ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ ìˆìŒ
        g.members.forEach(m => {
          const ratio = grandTotal > 0 ? (m.count || 0) / grandTotal : 0;
          gRows.push([
            g.label,
            m.text,
            m.count || 0,
            ratio
          ]);
        });
      })
      
      const ws2 = XLSX.utils.aoa_to_sheet([gHeader, ...gRows])
      ws2['!cols']=[{wch:30},{wch:40},{wch:12},{wch:12}]
      
      // ë¹„ìœ¨ ì—´ì„ í¼ì„¼íŠ¸ í˜•ì‹ìœ¼ë¡œ
      for(let R = 1; R <= gRows.length; R++) {
        const cellRef = XLSX.utils.encode_cell({r: R, c: 3});
        if(ws2[cellRef]) ws2[cellRef].z = "0.0%";
      }
      
      XLSX.utils.book_append_sheet(wb, ws2, safeSheetName('GPT_2ì°¨_ë¶„ë¥˜'))
    }

    const fname = `${safeFileName(sheetName1)}_ììœ ì—°ìƒ_ë¶„ì„.xlsx`
    XLSX.writeFile(wb, fname)
  })

  // ---------- ë Œë”ë§ & ìœ í‹¸ ---------- //
  function renderTable(columns, rows) {
    let h = '<table><thead><tr>' +
      columns.map(c => `<th>${escapeHtml(c.label)}</th>`).join('') +
      '</tr></thead><tbody>';
    for (const r of rows) {
      h += '<tr>' +
        columns.map(c => {
          let v = r[c.key] ?? '';
          if (c.key === 'ì‘ë‹µ_ë¹„ìœ¨' && typeof v === 'number') {
            v = (v * 100).toFixed(1) + '%';
          }
          return `<td>${escapeHtml(v)}</td>`;
        }).join('') +
        '</tr>';
    }
    return h + '</tbody></table>';
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({
      "&":"&amp;",
      "<":"&lt;",
      ">":"&gt;",
      "\"":"&quot;",
      "'":"&#39;"
    }[c]));
  }

  function safeFileName(s){return String(s||'result').replace(/[^\wê°€-í£\-_.]+/g,'_').slice(0,100)}
  function safeSheetName(s){ s=String(s||'Sheet').replace(/[\\\/*\[\]:?]/g,'_'); if(s.length>31) s=s.slice(0,31); if(!s.trim()) s='Sheet'; return s }
  function hashStr(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0 } return Math.abs(h) }
  
  // ---------- GPT ê²°ê³¼ ë³´ì • ë° í‘œì‹œ ---------- //
  function normalizeGptGroups(data) {
    console.log('ğŸ“ normalizeGptGroups ì…ë ¥:', data);
    
    // 0) í”í•œ ë‹¨ì¼ í‚¤ ë˜í•‘ í•´ì œ (data / result)
    let cur = data;
    for (let i = 0; i < 2; i++) {
      if (cur && typeof cur === 'object' && 'data' in cur && Object.keys(cur).length === 1) {
        cur = cur.data;
      } else if (cur && typeof cur === 'object' && 'result' in cur && Object.keys(cur).length === 1) {
        cur = cur.result;
      } else {
        break;
      }
    }

    // 1) ëŒ€í‘œ í‚¤ í›„ë³´êµ°ì„ ë„“í˜
    const keys = ['groups','groupings','clusters','categories','themes','buckets','topics','labels','results','output','classification'];
    const pick = (obj) => {
      for (const k of keys) if (Array.isArray(obj?.[k])) return obj[k];
      return null;
    };

    if (cur && typeof cur === 'object') {
      const arr = pick(cur);
      if (arr) {
        const out = arr.map(g => {
          const label = String(g?.label ?? g?.name ?? g?.title ?? '').trim();
          const rawMembers = Array.isArray(g?.members) ? g.members
                          : Array.isArray(g?.items)   ? g.items
                          : [];
          const members = rawMembers.map(m => {
            if (typeof m === 'string') return { text: m.trim(), count: 1 };
            const text  = String(m?.text ?? m?.name ?? m?.value ?? '').trim();
            const count = Number.isFinite(m?.count) ? Number(m.count) : 1;
            return { text, count };
          }).filter(x => x.text);
          return { label, members };
        }).filter(g => g.label && g.members.length);
        if (out.length) return out;
      }
    }

    // 1.5) OpenAI choices êµ¬ì¡° ì§ì ‘ íŒŒì‹± ì‹œë„
    if (cur?.choices?.[0]?.message?.content) {
      let msgContent = cur.choices[0].message.content;
      if (typeof msgContent === 'string') {
        // ì½”ë“œë¸”ë¡ ì œê±° (```json ... ``` ë˜ëŠ” ``` ... ```)
        const fencedMatch = msgContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
        if (fencedMatch?.[1]) {
          msgContent = fencedMatch[1];
          console.log('ğŸ“ ì½”ë“œë¸”ë¡ ì œê±° ì™„ë£Œ');
        }
        
        try {
          const parsed = JSON.parse(msgContent);
          console.log('ğŸ“¦ choices[0].message.contentë¥¼ JSONìœ¼ë¡œ íŒŒì‹± ì„±ê³µ:', parsed);
          const recursiveResult = normalizeGptGroups(parsed);
          if (recursiveResult && recursiveResult.length) return recursiveResult;
        } catch (e) {
          console.log('choices[0].message.contentëŠ” JSONì´ ì•„ë‹˜, í…ìŠ¤íŠ¸ íŒŒì‹± ì‹œë„');
        }
      }
    }

    // 2) choices ë“±ì— í…ìŠ¤íŠ¸ë¡œ ë“¤ì–´ì˜¨ ê²½ìš°(ëª¨ë¸ ììœ  ì¶œë ¥)
    const textCandidates = [
      cur?.choices?.[0]?.message?.content,
      cur?.choices?.[0]?.text,
      cur?.content, cur?.text, cur?.message, cur?.response,
      typeof cur === 'string' ? cur : null
    ].filter(Boolean);

    const tryParseLoose = (raw) => {
      if (typeof raw !== 'string') return null;
      // ```json ...``` ë˜ëŠ” ``` ...``` ì½”ë“œë¸”ë¡ ì œê±°
      const fenced = raw.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
      const bodies = [];
      if (fenced?.[1]) bodies.push(fenced[1]);
      bodies.push(raw);

      for (const s of bodies) {
        const m = s.match(/\{[\s\S]*\}/);
        if (!m) continue;
        try {
          const obj = JSON.parse(m[0]);
          const out = normalizeGptGroups(obj); // ì¬ê·€ì ìœ¼ë¡œ ë™ì¼ ê·œì¹™ ì ìš©
          if (out && out.length) return out;
        } catch {}
      }
      return null;
    };

    for (const t of textCandidates) {
      const g = tryParseLoose(String(t));
      if (g && g.length) return g;
    }

    console.warn('âš ï¸ normalizeGptGroups: ìœ íš¨í•œ ê·¸ë£¹ì„ ì°¾ì§€ ëª»í•¨');
    return [];
  }

  function renderGptGroups(groups){
    // ê²°ê³¼ ì˜ì—­: 2ì°¨ ìµœì‹  ë²„ì „ìœ¼ë¡œ ë®ì–´ì“°ê¸°
    const card=document.createElement('div'); card.className='card'
    const title=document.createElement('h3'); title.textContent='ğŸ§  2ì°¨ ë¶„ë¥˜ ê²°ê³¼(Latest)'; title.style.margin='0 0 8px'
    card.appendChild(title)

    const tbldiv=document.createElement('div'); tbldiv.style.overflow='auto'
    
    // í…Œì´ë¸” ìŠ¤íƒ€ì¼ ì¶”ê°€
    const style = document.createElement('style');
    style.textContent = `
      .gpt-result-table { width: 100%; table-layout: fixed; }
      .gpt-result-table th:nth-child(1),
      .gpt-result-table td:nth-child(1) { width: 180px; }
      .gpt-result-table th:nth-child(2),
      .gpt-result-table td:nth-child(2) { width: 100px; text-align: center; }
      .gpt-result-table th:nth-child(3),
      .gpt-result-table td:nth-child(3) { width: auto; }
    `;
    document.head.appendChild(style);
    
    const columns = [
      { key:'ê·¸ë£¹',                label:'ê·¸ë£¹' },
      { key:'í•©ê³„_ë¹ˆë„',          label:'í•©ê³„ ë¹ˆë„' },
      { key:'êµ¬ì„±',               label:'êµ¬ì„± (1ì°¨ ë¶„ë¥˜ëœ ì‘ë‹µ ê¸°ì¤€)' }
    ]
    const rows = groups.map(g=>{
      // ê·¸ë£¹ëª…ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš© (ì´ë¯¸ 'ê·¸ ì™¸ ì‘ë‹µ'ìœ¼ë¡œ ìƒì„±ë¨)
      let groupLabel = g.label;
      
      // êµ¬ì„± í‘œì‹œ: 'ê·¸ ì™¸ ì‘ë‹µ'ì€ ìƒì„¸ ìˆ¨ê¹€
      let composition;
      if (g.label === 'ê·¸ ì™¸ ì‘ë‹µ') {
        composition = 'ì—‘ì…€ì—ì„œ ìƒì„¸ í™•ì¸';
      } else {
        composition = g.members.map(m=>`${m.text} (${m.count})`).join(', ');
      }
      
      return {
        'ê·¸ë£¹': groupLabel,
        'í•©ê³„_ë¹ˆë„': String(g.members.reduce((s,m)=>s+(m.count||0),0)),
        'êµ¬ì„±': composition
      };
    })
    
    let html = '<table class="gpt-result-table"><thead><tr>' +
      columns.map(c => `<th>${escapeHtml(c.label)}</th>`).join('') +
      '</tr></thead><tbody>';
    for (const r of rows) {
      html += '<tr>' +
        columns.map(c => {
          let v = r[c.key] ?? '';
          return `<td>${escapeHtml(v)}</td>`;
        }).join('') +
        '</tr>';
    }
    html += '</tbody></table>';
    
    tbldiv.innerHTML = html;
    card.appendChild(tbldiv)

    const $results=document.getElementById('results')
    $results.innerHTML=''
    $results.appendChild(card)
  }

  </script>
</body>
</html>

